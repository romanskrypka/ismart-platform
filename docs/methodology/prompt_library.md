# Библиотека готовых промптов для Cursor

## Оглавление

1.  [Введение: Как использовать эту библиотеку](#1-введение-как-использовать-эту-библиотеку)
2.  [Категория 1: Архитектура и планирование](#2-категория-1-архитектура-и-планирование)
3.  [Категория 2: CRUD (Модели, Представления, Формы, Шаблоны)](#3-категория-2-crud-модели-представления-формы-шаблоны)
4.  [Категория 3: API (Django Rest Framework)](#4-категория-3-api-django-rest-framework)
5.  [Категория 4: Тестирование](#5-категория-4-тестирование)
6.  [Категория 5: Рефакторинг и качество кода](#6-категория-5-рефакторинг-и-качество-кода)
7.  [Категория 6: Искусственный интеллект (Агенты, RAG)](#7-категория-6-искусственный-интеллект-агенты-rag)
8.  [Категория 7: Безопасность](#8-категория-7-безопасность)

---

## 1. Введение: Как использовать эту библиотеку

Эта библиотека — ваш арсенал для ежедневной работы в Cursor. Она содержит коллекцию готовых, проверенных промптов для большинства типовых задач. Вместо того чтобы каждый раз придумывать промпт с нуля, найдите подходящий шаблон здесь, скопируйте его и замените плейсхолдеры (например, `[model_name]`) на ваши значения.

**Ключевой принцип:** Эффективность через стандартизацию. Используя эти промпты, вы получаете предсказуемый и качественный результат, так как они уже настроены на работу с методологиями PCAM, GRACE и FLEX.

---

## 2. Категория 1: Архитектура и планирование

### 1.1. Промпт для старта нового проекта

-   **Назначение:** Инициализация проекта, создание архитектуры и плана реализации.
-   **Контекст:** `@docs/DEVELOPMENT_PLAN.md`, `@docs/USER_PROFILE.xml`

```
Режим: Architect.
Загрузи: @docs/DEVELOPMENT_PLAN.md и @docs/USER_PROFILE.xml

Задача: Спроектировать скелет Django-проекта для Фазы 1 из Development Plan.

Следуй плейбуку из @.cursor/rules/rules-architect.md:
1. STUDY — изучи план и профиль
2. VERIFY — задай мне уточняющие вопросы
3. DESIGN — предложи структуру модулей с MODULE_CONTRACT для каждого
4. DOCUMENT — обнови DEVELOPMENT_PLAN.md

НЕ ПИШИ КОД. Только план и контракты.
```

### 1.2. Промпт для ежедневного планирования

-   **Назначение:** Получить план работы на день.
-   **Контекст:** `@docs/DEVELOPMENT_PLAN.md`

```
Загрузи: @docs/DEVELOPMENT_PLAN.md

Какая сейчас текущая фаза? Какие задачи не завершены?
Предложи план работы на сегодня (3-5 микрозадач).
```

---

## 3. Категория 2: CRUD (Модели, Представления, Формы, Шаблоны)

### 2.1. Промпт для генерации модели Django

-   **Назначение:** Создать новую модель с полной GRACE-разметкой.
-   **Контекст:** `@docs/DEVELOPMENT_PLAN.md` (раздел с моделями данных)

```
Режим: Code.

Задача: Создать модель `[model_name]` в файле `[app_name]/models.py`.

Поля модели:
- [field_1]: [type] ([options])
- [field_2]: [type] ([options])

Требования:
1. Добавь полную GRACE-разметку (MODULE_CONTRACT, MODULE_MAP, CONTRACT для методов).
2. Добавь строковое представление `__str__`.
3. Зарегистрируй модель в `[app_name]/admin.py`.
```

### 2.2. Промпт для генерации полного CRUD для модели

-   **Назначение:** Создать все необходимые компоненты для управления моделью через веб-интерфейс.
-   **Контекст:** `@[app_name]/models.py::[model_name]`

```
Режим: Architect.

Задача: Спроектировать полный CRUD для модели `@app_name/models.py::[model_name]`.

План:
1.  **Форма:** Создать `[model_name]Form` в `[app_name]/forms.py`.
2.  **Views:** Создать 4 class-based views в `[app_name]/views.py`:
    -   `[model_name]ListView` (ListView)
    -   `[model_name]DetailView` (DetailView)
    -   `[model_name]CreateView` (CreateView)
    -   `[model_name]UpdateView` (UpdateView)
3.  **URL-адреса:** Добавить 4 маршрута в `[app_name]/urls.py`.
4.  **Шаблоны:** Создать 4 шаблона в `templates/[app_name]/`:
    -   `[model_name]_list.html`
    -   `[model_name]_detail.html`
    -   `[model_name]_form.html` (для создания и обновления)
    -   `[model_name]_confirm_delete.html`

Представь контракты для каждого нового файла. После моего утверждения переходи к реализации в режиме Code.
```

---

## 4. Категория 3: API (Django Rest Framework)

### 4.1. Промпт для генерации Serializer и ViewSet

-   **Назначение:** Создать API для модели.
-   **Контекст:** `@[app_name]/models.py::[model_name]`

```
Режим: Code.

Задача: Создать API для модели `@app_name/models.py::[model_name]`.

Действуй по шагам:
1.  Создай `[model_name]Serializer` в `[app_name]/serializers.py`. Включи все поля модели.
2.  Создай `[model_name]ViewSet` (ModelViewSet) в `[app_name]/views.py`.
3.  Добавь полную GRACE-разметку в оба файла.
```

### 4.2. Промпт для настройки роутера API

-   **Назначение:** Зарегистрировать ViewSet и сделать его доступным по URL.
-   **Контекст:** `@[app_name]/views.py::[model_name]ViewSet`

```
Режим: Code.

Задача: Зарегистрировать `@app_name/views.py::[model_name]ViewSet` в роутере DRF.

Создай файл `[app_name]/urls.py` (если его нет) и добавь в него:
1. Импортируй `DefaultRouter` из `rest_framework.routers`.
2. Импортируй `[model_name]ViewSet`.
3. Создай роутер и зарегистрируй в нём viewset с префиксом `[url_prefix]`.
4. Добавь `router.urls` в `urlpatterns`.
```

---

## 5. Категория 4: Тестирование

### 5.1. Промпт для генерации тестов для модели

-   **Назначение:** Написать unit-тесты для кастомных методов модели.
-   **Контекст:** `@[app_name]/models.py::[model_name]`, `@docs/testing_guide.md`

```
Режим: Code.
Загрузи: @docs/testing_guide.md

Задача: Написать unit-тесты для модели `@app_name/models.py::[model_name]`.

Нужно протестировать метод `[method_name]()`.

Создай файл `tests/test_models.py` и напиши тест, который проверяет:
1. Случай, когда метод должен вернуть `True`.
2. Случай, когда метод должен вернуть `False`.

Используй `self.assertTrue()` и `self.assertFalse()`. Добавь GRACE-разметку.
```

### 5.2. Промпт для генерации тестов для API

-   **Назначение:** Написать integration-тесты для API эндпоинтов.
-   **Контекст:** `@[app_name]/views.py::[model_name]ViewSet`, `@docs/testing_guide.md`

```
Режим: Code.
Загрузи: @docs/testing_guide.md

Задача: Написать integration-тесты для `@app_name/views.py::[model_name]ViewSet`.

Создай файл `tests/test_api.py` и напиши тесты для 5 стандартных действий:
1. `list` (GET /api/[url_prefix]/) - проверка статуса 200 и количества объектов.
2. `create` (POST /api/[url_prefix]/) - проверка статуса 201 и созданных данных.
3. `retrieve` (GET /api/[url_prefix]/{id}/) - проверка статуса 200 и данных объекта.
4. `update` (PUT /api/[url_prefix]/{id}/) - проверка статуса 200 и обновлённых данных.
5. `destroy` (DELETE /api/[url_prefix]/{id}/) - проверка статуса 240 и отсутствия объекта в БД.

Используй `APITestCase`.
```

---

## 6. Категория 5: Рефакторинг и качество кода

### 6.1. Промпт для добавления полной GRACE-разметки

-   **Назначение:** Добавить семантическую разметку к существующему файлу.
-   **Контекст:** `@[path/to/file.py]`

```
Прочитай файл @[path/to/file.py]
Добавь полную GRACE-разметку:
1. MODULE_CONTRACT в начало
2. MODULE_MAP после контракта
3. CONTRACT для каждого метода
4. BLOCK-разметку для логических блоков (>10 строк)
5. Логирование в формате [LEVEL][Class][Method][Step]

НЕ МЕНЯЙ существующую логику. Только разметка и логирование.
```

### 6.2. Промпт для рефакторинга функции/метода

-   **Назначение:** Улучшить читаемость, производительность или структуру кода.
-   **Контекст:** `@[path/to/file.py]::[function_name]`

```
Режим: Code.

Задача: Провести рефакторинг функции `@path/to/file.py::[function_name]`.

Текущая проблема: [описать проблему, например, "функция слишком длинная и делает много вещей", "используется медленный цикл"]

Цель рефакторинга: [описать цель, например, "разбить на 2-3 вспомогательные функции", "заменить цикл на ORM-запрос"]

Предложи изменения в формате diff. Сохрани существующую функциональность.
```

---

## 7. Категория 6: Искусственный интеллект (Агенты, RAG)

### 7.1. Промпт для создания ИИ-агента

-   **Назначение:** Спроектировать и создать простого ИИ-агента по паттерну ReAct.
-   **Контекст:** `@docs/specialized_systems_guide.md`

```
Режим: Architect.
Загрузи: @docs/specialized_systems_guide.md (раздел про ИИ-агентов)

Задача: Спроектировать ИИ-агента `[agent_name]`.

Цель агента: [описать цель, например, "анализировать отзывы клиентов и создавать задачи в Jira"]

Инструменты агента:
1. `search_reviews(query)`: ищет отзывы
2. `analyze_sentiment(text)`: анализирует тональность
3. `create_jira_ticket(summary, description)`: создаёт тикет

Предложи архитектуру агента:
1. Класс агента `[agent_name]Agent`.
2. Основной метод `run(query)` с циклом ReAct (Thought, Action, Observation).
3. Промпт для LLM, который будет управлять агентом.

После утверждения переходи к реализации.
```

---

## 8. Категория 7: Безопасность

### 8.1. Промпт для аудита безопасности

-   **Назначение:** Проверить проект на наличие основных уязвимостей.
-   **Контекст:** `@docs/security_guide.md`

```
Режим: Architect.
Загрузи: @docs/security_guide.md

Задача: Провести аудит безопасности проекта по OWASP Top 10.

Для каждой уязвимости из гайда:
1. Сформулируй, что будешь искать.
2. Проанализируй код.
3. Сообщи о найденных потенциальных уязвимостях или подтверди, что защита на месте.

Начни с A01: Broken Access Control.
```
