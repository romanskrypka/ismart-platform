# Универсальный шаблон запуска нового проекта в Cursor
## Первичная настройка и техническое задание по методологиям PCAM + GRACE + FLEX

---

## Оглавление

1. [Философия: как три методологии работают вместе](#1-философия-как-три-методологии-работают-вместе)
2. [Фаза 0: Подготовка до открытия Cursor](#2-фаза-0-подготовка-до-открытия-cursor)
3. [Фаза 1: Создание структуры папок и файлов правил](#3-фаза-1-создание-структуры-папок-и-файлов-правил)
4. [Фаза 2: Написание глобальных правил (.cursorrules)](#4-фаза-2-написание-глобальных-правил-cursorrules)
5. [Фаза 3: Создание правил для режимов (Architect / Code / Debug)](#5-фаза-3-создание-правил-для-режимов-architect--code--debug)
6. [Фаза 4: Составление первого технического задания (Development Plan)](#6-фаза-4-составление-первого-технического-задания-development-plan)
7. [Фаза 5: Первый запуск — генерация скелета проекта](#7-фаза-5-первый-запуск--генерация-скелета-проекта)
8. [Фаза 6: Разметка сгенерированного кода по GRACE](#8-фаза-6-разметка-сгенерированного-кода-по-grace)
9. [Фаза 7: Настройка Log Driven Development](#9-фаза-7-настройка-log-driven-development)
10. [Фаза 8: Интеграция FLEX (если используются SLM)](#10-фаза-8-интеграция-flex-если-используются-slm)
11. [Чек-лист запуска нового проекта](#11-чек-лист-запуска-нового-проекта)
12. [Приложение A: Шаблоны всех файлов](#приложение-a-шаблоны-всех-файлов)
13. [Приложение B: Готовые промпты для каждой фазы](#приложение-b-готовые-промпты-для-каждой-фазы)

---

## 1. Философия: как три методологии работают вместе

Прежде чем создавать файлы, необходимо понять роль каждой методологии и момент её применения.

| Методология | Роль | Когда применяется | Что даёт Cursor |
|---|---|---|---|
| **PCAM** | Управление целями и планирование | До написания кода и при постановке задач | Cursor понимает ЗАЧЕМ писать код, а не только ЧТО |
| **GRACE** | Семантическая разметка кода | Во время и после генерации кода | Cursor видит СТРУКТУРУ проекта через контракты и блоки |
| **FLEX** | Промптинг для SLM-агентов | При работе с локальными моделями и агентами | SLM-агенты точно выбирают инструменты через XML + few-shot |

Порядок применения при запуске нового проекта:

```
PCAM (цель → план → контракты)
  ↓
GRACE (разметка кода → навигация ИИ)
  ↓
FLEX (если есть SLM-агенты → XML-промпты для них)
```

**Ключевой принцип:** Cursor — это ваш основной "сотрудник". Всё, что вы создаёте в файлах правил и разметке, предназначено для того, чтобы этот сотрудник понимал проект так же глубоко, как вы сами.

---

## 2. Фаза 0: Подготовка до открытия Cursor

Эта фаза выполняется вне Cursor — в голове и на бумаге (или в любом текстовом редакторе). Цель — сформулировать видение проекта по принципам PCAM.

### Микрошаг 0.1: Сформулировать цель проекта одним предложением

По PCAM, ИИ-агент работает лучше всего, когда у него есть чёткая **цель** (alignment). Запишите:

```
ЦЕЛЬ ПРОЕКТА: [Одно предложение, описывающее что делает продукт и для кого]
```

**Пример:**
```
ЦЕЛЬ ПРОЕКТА: Веб-платформа для автоматизации складской логистики 
с ИИ-агентами, которая позволяет операторам управлять приёмкой, 
размещением и отгрузкой товаров через единый интерфейс.
```

### Микрошаг 0.2: Определить 3-5 бизнес-сценариев

По PCAM, Development Plan строится вокруг бизнес-сценариев, а не технических задач. Запишите основные сценарии использования:

```
БИЗНЕС-СЦЕНАРИИ:
1. [Кто] → [Что делает] → [Какой результат]
2. ...
3. ...
```

**Пример:**
```
БИЗНЕС-СЦЕНАРИИ:
1. Оператор склада → сканирует штрих-код товара → система показывает 
   ячейку размещения и обновляет остатки
2. Менеджер → запрашивает отчёт по оборачиваемости → ИИ-агент 
   анализирует данные и генерирует отчёт с рекомендациями
3. Система → обнаруживает низкий остаток → автоматически формирует 
   заявку на пополнение
```

### Микрошаг 0.3: Определить технический стек

```
СТЕК:
- Язык: Python 3.11+
- Фреймворк: Django 5.x
- БД: SQLite (MVP) → PostgreSQL (продакшен)
- Фронтенд: Django Templates + HTMX (или React, если SPA)
- ИИ: OpenAI API / Alibaba Cloud
- Деплой: Alibaba Cloud (без Docker)
```

### Микрошаг 0.4: Определить границы MVP

По PCAM, нулевая терпимость к техническому долгу начинается с чёткого определения границ:

```
MVP ВКЛЮЧАЕТ:
- Сценарий 1 (полностью)
- Сценарий 2 (базовая версия)

MVP НЕ ВКЛЮЧАЕТ:
- Сценарий 3 (отложен на v2)
- Мобильное приложение
- Интеграция с 1С
```

---

## 3. Фаза 1: Создание структуры папок и файлов правил

### Микрошаг 1.1: Создать корневую папку проекта

```bash
mkdir my-project
cd my-project
git init
```

### Микрошаг 1.2: Создать структуру папок для правил Cursor

Cursor читает правила из папки `.cursor/rules/`. Создайте следующую структуру:

```bash
mkdir -p .cursor/rules
```

Итоговая структура файлов правил:

```
my-project/
├── .cursorrules                          # Глобальные правила (PCAM + GRACE)
├── .cursor/
│   └── rules/
│       ├── rules-architect.md            # Правила для режима Architect
│       ├── rules-code.md                 # Правила для режима Code
│       ├── rules-debug.md                # Правила для режима Debug
│       └── rules-flex.md                 # Правила FLEX (для SLM-агентов)
├── docs/
│   ├── USER_PROFILE.xml                  # Профиль оператора (PCAM)
│   ├── DEVELOPMENT_PLAN.md               # Техническое задание (PCAM)
│   ├── KNOWLEDGE_GRAPH.xml               # Граф знаний проекта (GRACE, уровень 1)
│   └── dynamic_logging_heuristics.md     # Гайд по логированию (PCAM)
├── src/                                  # Исходный код (появится позже)
├── tests/                                # Тесты (появится позже)
└── logs/                                 # Логи приложения (PCAM: Log Driven Dev)
```

### Микрошаг 1.3: Скопировать USER_PROFILE.xml в проект

```bash
mkdir docs
cp /путь/к/USER_PROFILE.xml docs/USER_PROFILE.xml
```

Этот файл уже создан ранее. Cursor будет обращаться к нему через `@docs/USER_PROFILE.xml` в промптах.

---

## 4. Фаза 2: Написание глобальных правил (.cursorrules)

Файл `.cursorrules` в корне проекта — это главный файл, который Cursor читает **всегда**. Здесь объединяются принципы PCAM и GRACE.

### Микрошаг 2.1: Создать файл .cursorrules

Создайте файл `.cursorrules` в корне проекта со следующим содержимым. Каждый блок прокомментирован — какой методологии он принадлежит и зачем нужен.

```markdown
# === ГЛОБАЛЬНЫЕ ПРАВИЛА ПРОЕКТА ===
# Этот файл читается Cursor при КАЖДОМ запросе.

## Профиль оператора (PCAM: User Profile)
Оператор: Роман. Роль: продакт-менеджер и фрилансер с 10-летним опытом.
Язык общения: русский. Стиль ответов: развёрнутые с объяснениями.
Выполнение: микрошагами. Перед началом работы — задавай уточняющие вопросы.
Полный профиль: @docs/USER_PROFILE.xml

## Цель проекта (PCAM: Alignment на цель)
[ВСТАВИТЬ ЦЕЛЬ ИЗ ФАЗЫ 0, МИКРОШАГ 0.1]

## Технический стек
- Python 3.11+, Django 5.x
- SQLite (MVP) → PostgreSQL (продакшен)
- Без Docker (ограничение по диску)
- Деплой: Alibaba Cloud
- Пакетные менеджеры: pip, npm

## Стандарты кодирования (GRACE: семантическая разметка)

### Обязательная разметка каждого файла
Каждый Python-файл ОБЯЗАН содержать:

1. **MODULE_CONTRACT** — в начале файла:
```python
# FILE: путь/к/файлу.py
# VERSION: x.y.z
# START_MODULE_CONTRACT:
#   PURPOSE: [Зачем существует этот модуль. 1-3 предложения.]
#   SCOPE: [Ключевые слова через запятую]
#   DEPENDENCIES: [От каких модулей зависит]
# END_MODULE_CONTRACT
```

2. **MODULE_MAP** — после контракта:
```python
# START_MODULE_MAP:
#   CLASS => ИмяКласса
#     METHOD 1 [Краткое описание] => имя_метода
#     METHOD 2 [Краткое описание] => имя_метода
# END_MODULE_MAP
```

3. **CONTRACT для каждого метода/функции**:
```python
# START_CONTRACT:
#   PURPOSE: [Что делает этот метод]
#   INPUTS: [Что принимает]
#   OUTPUTS: [Что возвращает]
#   SIDE_EFFECTS: [Побочные эффекты, если есть]
# END_CONTRACT
```

4. **BLOCK-разметка** для логических блоков внутри функций:
```python
# START_BLOCK_НАЗВАНИЕ: [Краткое описание блока]
...код...
# END_BLOCK_НАЗВАНИЕ
```

### Стандарты именования
- Python: snake_case (переменные, функции), PascalCase (классы)
- JavaScript: camelCase (переменные, функции), PascalCase (классы)
- Придерживаться нотаций конкретного языка

### Комментарии
- Подробные комментарии в коде обязательны
- Каждый нетривиальный блок логики должен иметь объяснение ЗАЧЕМ, а не ЧТО

## Логирование (PCAM: Log Driven Development)
Каждое значимое действие логируется в формате:
```python
logger.info(f"[INFO][{self.__class__.__name__}][{method_name}][StepName] Описание")
logger.error(f"[ERROR][{self.__class__.__name__}][{method_name}][StepName] Описание | {error}")
```

Формат лога: `[LEVEL][Class][Method][Step] Message`
Это позволяет ИИ-агенту навигировать от лога к конкретному блоку кода.

## Контрактное программирование (PCAM)
При получении задачи на создание нового модуля/функции:
1. Сначала опиши контракт (~500 токенов): цель, вход, выход, теги, примеры
2. Затем реализуй код (~1000-3000 токенов)
3. Контракт пишется ДО кода, не после

## Запрещено
- Удалять или изменять существующую разметку (MODULE_CONTRACT, BLOCK и т.д.)
- Генерировать код без контракта
- Использовать Docker
- Оставлять функции без комментариев
```

### Микрошаг 2.2: Адаптировать под свой проект

Замените `[ВСТАВИТЬ ЦЕЛЬ ИЗ ФАЗЫ 0]` на реальную цель вашего проекта. Если стек отличается — скорректируйте секцию "Технический стек".

---

## 5. Фаза 3: Создание правил для режимов (Architect / Code / Debug)

По GRACE, работа в Cursor делится на три режима. Каждый режим имеет свой файл правил и свой плейбук (пошаговый алгоритм).

### Микрошаг 3.1: Создать rules-architect.md

Файл `.cursor/rules/rules-architect.md`:

```markdown
# Режим: ARCHITECT
# Активация: используй этот режим при проектировании новых модулей, 
# планировании архитектуры, декомпозиции задач.

## Твоя роль
Ваша главная задача в этом режиме — НЕ ПИСАТЬ КОД, а проектировать его.
Вы должны следовать структурированному планированию.

## Классификация задачи
Определи тип задачи:
- **Greenfield** — новый проект или крупный модуль с нуля
- **Targeted** — новая функциональность в существующем проекте

## Плейбук (обязательные шаги)

### Шаг 1: STUDY (Изучение)
**Цель:** Изучить контекст задачи.
1. Прочитай DEVELOPMENT_PLAN.md — пойми текущую фазу проекта
2. Прочитай USER_PROFILE.xml — учти предпочтения оператора
3. Если Targeted — изучи MODULE_CONTRACT затрагиваемых модулей
4. Если Targeted — изучи KNOWLEDGE_GRAPH.xml для понимания связей
5. Сформулируй: "Я понял задачу как: [переформулировка]"

### Шаг 2: VERIFY (Верификация понимания)
**Цель:** Убедиться, что понимание задачи корректно.
1. Задай оператору 2-3 уточняющих вопроса
2. Проверь: не конфликтует ли задача с существующей архитектурой?
3. Проверь: укладывается ли задача в границы MVP?

### Шаг 3: DESIGN (Проектирование)
**Цель:** Создать план реализации.
1. Определи какие модули нужно создать/изменить
2. Для каждого нового модуля напиши MODULE_CONTRACT:
   - PURPOSE (зачем)
   - SCOPE (область)
   - DEPENDENCIES (зависимости)
3. Для каждого нового метода напиши CONTRACT:
   - PURPOSE, INPUTS, OUTPUTS
4. Определи порядок реализации (какой модуль первый)
5. Оцени объём: сколько файлов, сколько методов

### Шаг 4: DOCUMENT (Документирование)
**Цель:** Зафиксировать решения.
1. Обнови DEVELOPMENT_PLAN.md — добавь новую задачу
2. Если создаётся новый модуль — обнови KNOWLEDGE_GRAPH.xml
3. Представь результат оператору для утверждения

## Формат вывода
Результат работы в режиме Architect — это ПЛАН, а не код:
- Список модулей с контрактами
- Порядок реализации
- Вопросы и решения
```

### Микрошаг 3.2: Создать rules-code.md

Файл `.cursor/rules/rules-code.md`:

```markdown
# Режим: CODE
# Активация: используй этот режим при реализации кода по готовому плану.

## Твоя роль
Ваша главная задача в этом режиме — ИСПОЛНЯТЬ, а не планировать.
Вы реализуете решения, обеспечиваете их техническую корректность.

## Плейбук (обязательные шаги)

### Шаг 1: ANALYZE_THE_CONTEXT (Анализ контекста)
**Цель:** Понять что именно нужно реализовать.
1. Прочитай контракт модуля (MODULE_CONTRACT), который нужно реализовать
2. Прочитай контракты методов (CONTRACT), если они уже написаны
3. Изучи связанные модули через CrossLinks или KNOWLEDGE_GRAPH
4. Сформулируй: "Я буду реализовывать: [что именно]"

### Шаг 2: VERIFY (Проверка перед кодированием)
**Цель:** Убедиться, что все зависимости на месте.
1. Проверь: существуют ли модули из DEPENDENCIES?
2. Проверь: совместимы ли INPUTS/OUTPUTS с вызывающим кодом?
3. Если чего-то не хватает — сообщи оператору

### Шаг 3: IMPLEMENT (Реализация)
**Цель:** Написать код по контракту.
1. Создай файл с MODULE_CONTRACT и MODULE_MAP в начале
2. Реализуй каждый метод, начиная с CONTRACT-комментария
3. Внутри методов используй BLOCK-разметку для логических блоков
4. Добавь логирование в формате: [LEVEL][Class][Method][Step]
5. Добавь подробные комментарии к нетривиальной логике

### Шаг 4: VALIDATE (Валидация)
**Цель:** Проверить результат.
1. Перечитай MODULE_CONTRACT — код соответствует PURPOSE?
2. Все методы из MODULE_MAP реализованы?
3. Все BLOCK-разметки парные (START/END)?
4. Логирование добавлено к ключевым операциям?
5. Нет ли нарушений из секции "Запрещено" в .cursorrules?

## Правила генерации кода
- Каждый файл начинается с MODULE_CONTRACT
- Каждый класс/функция начинается с CONTRACT
- Логические блоки оборачиваются в START_BLOCK/END_BLOCK
- Патчи применяются через SEARCH/REPLACE блоки (не через полную перезапись)
- При изменении существующего кода — обнови VERSION в MODULE_CONTRACT
```

### Микрошаг 3.3: Создать rules-debug.md

Файл `.cursor/rules/rules-debug.md`:

```markdown
# Режим: DEBUG
# Активация: используй этот режим при диагностике и исправлении ошибок.

## Твоя роль
Ваша главная задача в этом режиме — СИСТЕМАТИЧЕСКАЯ ДИАГНОСТИКА 
и устранение проблемы. Подтвердить диагноз и аккуратно исправить.

## Плейбук (обязательные шаги)

### Шаг 1: ANALYZE_THE_CONTEXT (Сбор информации)
**Цель:** Собрать всю доступную информацию о проблеме.
1. Внимательно изучи сообщение об ошибке и стек вызовов
2. Найди и изучи лог-файл (logs/app.log)
3. Используй BLOCK-разметку для навигации: найди блок, где произошла ошибка
4. Изучи MODULE_CONTRACT затронутого модуля
5. Сформулируй 2-3 наиболее вероятные гипотезы о причине

### Шаг 2: CONFIRM_THE_DIAGNOSIS (Подтверждение диагноза)
**Цель:** Подтвердить одну из гипотез.
1. Если информации недостаточно — примени динамическое логирование:
   - Загрузи @docs/dynamic_logging_heuristics.md
   - Добавь временные логи в подозрительные BLOCK-секции
   - Заяви: "Я добавлю логирование в [функция/блок] для проверки гипотезы [N]"
2. После добавления логов — попроси оператора перезапустить
3. Проанализируй новые логи
4. Заяви: "Подтверждённая причина: [описание]"

### Шаг 3: IMPLEMENT_FIX (Исправление)
**Цель:** Аккуратно исправить проблему.
1. Исправь ТОЛЬКО подтверждённую причину
2. Не меняй код за пределами проблемного BLOCK
3. Обнови VERSION в MODULE_CONTRACT
4. Добавь/обнови CHANGE_SUMMARY:
```python
# START_CHANGE_SUMMARY:
#   LAST_CHANGE: [Дата] — [Описание исправления]
# END_CHANGE_SUMMARY
```
5. Убедись, что исправление не нарушает CONTRACT метода

### Шаг 4: VERIFY_FIX (Верификация)
**Цель:** Убедиться, что исправление работает.
1. Проверь: ошибка больше не воспроизводится?
2. Проверь: не появились ли новые ошибки в логах?
3. Удали временное логирование (если добавлялось на шаге 2)
4. Сообщи оператору результат
```

---

## 6. Фаза 4: Составление первого технического задания (Development Plan)

По PCAM, техническое задание — это **Development Plan**, а не ToDo-список. Он содержит контекст, цели и критерии успеха.

### Микрошаг 4.1: Создать файл DEVELOPMENT_PLAN.md

Файл `docs/DEVELOPMENT_PLAN.md`:

```markdown
# Development Plan: [Название проекта]
# Версия: 0.1.0
# Дата: [Дата создания]

## 1. Видение проекта

### Цель
[Цель из Фазы 0, микрошаг 0.1]

### Бизнес-сценарии
[Сценарии из Фазы 0, микрошаг 0.2]

### Границы MVP
[Границы из Фазы 0, микрошаг 0.4]

## 2. Технический стек
[Стек из Фазы 0, микрошаг 0.3]

## 3. Архитектура (высокоуровневая)

### Модули системы
| Модуль | Назначение | Приоритет |
|---|---|---|
| core/ | Бизнес-логика | MVP |
| api/ | REST API | MVP |
| ui/ | Веб-интерфейс | MVP |
| agents/ | ИИ-агенты | v2 |
| integrations/ | Внешние интеграции | v2 |

### Зависимости между модулями
```
ui/ → api/ → core/ → db
agents/ → core/ → db
```

## 4. Фазы реализации

### Фаза 1: Скелет проекта (текущая)
**Цель:** Создать базовую структуру Django-проекта с настроенной БД.
**Критерии завершения:**
- [ ] Django-проект создан и запускается
- [ ] Модели данных для сценария 1 созданы
- [ ] Миграции применены
- [ ] Базовый шаблон UI работает
**Контракты модулей:** (будут заполнены в режиме Architect)

### Фаза 2: Бизнес-логика сценария 1
**Цель:** [Описание]
**Критерии завершения:**
- [ ] ...

### Фаза 3: ...

## 5. Решения и ограничения
| Решение | Причина | Альтернатива |
|---|---|---|
| SQLite для MVP | Простота, нет внешних зависимостей | PostgreSQL для продакшена |
| Без Docker | Ограничение по диску | Прямой деплой на Alibaba Cloud |
| Django Templates + HTMX | Быстрый MVP без SPA-сложности | React (если потребуется SPA) |

## 6. Журнал изменений
| Дата | Версия | Что изменилось |
|---|---|---|
| [Дата] | 0.1.0 | Первоначальная версия плана |
```

### Микрошаг 4.2: Заполнить план конкретными данными

Замените все плейсхолдеры `[...]` реальными данными вашего проекта. Это критически важно — Cursor будет обращаться к этому файлу как к "источнику правды".

---

## 7. Фаза 5: Первый запуск — генерация скелета проекта

Теперь все файлы настройки готовы. Открываем Cursor и начинаем работу.

### Микрошаг 5.1: Открыть проект в Cursor

```bash
cursor my-project/
```

### Микрошаг 5.2: Проверить, что Cursor видит правила

Откройте чат Cursor (Ctrl+L) и введите тестовый промпт:

```
Прочитай .cursorrules и подтверди, что ты понимаешь правила проекта.
Перечисли ключевые требования к разметке кода.
```

Cursor должен ответить, упомянув MODULE_CONTRACT, MODULE_MAP, BLOCK-разметку и формат логирования. Если нет — проверьте, что файл `.cursorrules` находится в корне проекта.

### Микрошаг 5.3: Первый промпт — режим Architect

Используйте следующий промпт для генерации архитектуры:

```
Режим: Architect.
Загрузи: @docs/DEVELOPMENT_PLAN.md и @docs/USER_PROFILE.xml

Задача: Спроектировать скелет Django-проекта для Фазы 1 
из Development Plan.

Следуй плейбуку из @.cursor/rules/rules-architect.md:
1. STUDY — изучи план и профиль
2. VERIFY — задай мне уточняющие вопросы
3. DESIGN — предложи структуру модулей с MODULE_CONTRACT для каждого
4. DOCUMENT — обнови DEVELOPMENT_PLAN.md

НЕ ПИШИ КОД. Только план и контракты.
```

### Микрошаг 5.4: Ответить на уточняющие вопросы Cursor

Cursor задаст вопросы (по плейбуку Architect, шаг VERIFY). Ответьте на них. Это нормальная часть процесса.

### Микрошаг 5.5: Утвердить архитектуру

После того как Cursor предложит план с контрактами модулей, проверьте:
- Все ли модули из DEVELOPMENT_PLAN учтены?
- Контракты понятны и корректны?
- Порядок реализации логичен?

Если всё ок, напишите: **"Утверждаю. Переходи к реализации."**

### Микрошаг 5.6: Второй промпт — режим Code

```
Режим: Code.
Загрузи: @.cursor/rules/rules-code.md

Задача: Реализовать скелет проекта по утверждённому плану.
Начни с первого модуля в порядке реализации.

Следуй плейбуку:
1. ANALYZE — прочитай контракт модуля
2. VERIFY — проверь зависимости
3. IMPLEMENT — создай файл с полной GRACE-разметкой
4. VALIDATE — проверь соответствие контракту

Создавай по одному файлу за раз. После каждого файла — жди 
моего подтверждения.
```

### Микрошаг 5.7: Проверять каждый сгенерированный файл

После генерации каждого файла проверяйте:
- [ ] Есть MODULE_CONTRACT в начале?
- [ ] Есть MODULE_MAP?
- [ ] Каждый метод имеет CONTRACT?
- [ ] Логические блоки обёрнуты в BLOCK?
- [ ] Логирование в формате `[LEVEL][Class][Method][Step]`?
- [ ] Подробные комментарии?

Если чего-то не хватает, скажите Cursor: **"Добавь недостающую разметку GRACE в файл X"**.

---

## 8. Фаза 6: Разметка сгенерированного кода по GRACE

Если Cursor сгенерировал код без полной разметки (или вы добавляете GRACE к существующему проекту), используйте следующий процесс.

### Микрошаг 6.1: Промпт для добавления MODULE_CONTRACT

```
Прочитай файл @src/core/models.py
Добавь в начало файла MODULE_CONTRACT по стандарту из .cursorrules:
- PURPOSE: зачем этот модуль
- SCOPE: ключевые слова
- DEPENDENCIES: от чего зависит

Затем добавь MODULE_MAP — перечисли все классы и методы.
НЕ МЕНЯЙ существующий код, только добавь разметку.
```

### Микрошаг 6.2: Промпт для добавления CONTRACT к методам

```
Прочитай файл @src/core/models.py
Для каждого метода, у которого нет CONTRACT, добавь:
- PURPOSE
- INPUTS  
- OUTPUTS
- SIDE_EFFECTS (если есть)

НЕ МЕНЯЙ логику методов. Только добавь комментарии-контракты.
```

### Микрошаг 6.3: Промпт для добавления BLOCK-разметки

```
Прочитай файл @src/core/views.py
Внутри каждого метода длиннее 10 строк найди логические блоки 
и оберни их в START_BLOCK/END_BLOCK с описанием.

Пример:
# START_BLOCK_VALIDATION: [Валидация входных данных запроса]
...код валидации...
# END_BLOCK_VALIDATION

НЕ МЕНЯЙ логику. Только добавь разметку блоков.
```

### Микрошаг 6.4: Создать KNOWLEDGE_GRAPH.xml (уровень 1 GRACE)

```
Режим: Architect.

Проанализируй все файлы в src/ и создай файл 
docs/KNOWLEDGE_GRAPH.xml — граф знаний проекта.

Формат:
<KnowledgeGraph>
  <ProjectName VERSION="0.1.0">
    <keywords>ключевые слова через запятую</keywords>
    <annotation>Общее описание проекта</annotation>
    <module FILE="путь/к/файлу" TYPE="тип модуля">
      <annotation>Описание из MODULE_CONTRACT</annotation>
      <class NAME="ИмяКласса">
        <annotation>Описание класса</annotation>
        <method NAME="имя_метода">
          <annotation>Описание из CONTRACT</annotation>
          <CrossLinks>
            <Link TARGET="связанный_модуль_метод" TYPE="CALLS"/>
          </CrossLinks>
        </method>
      </class>
    </module>
  </ProjectName>
</KnowledgeGraph>

Этот файл — карта проекта для ИИ-навигации.
```

---

## 9. Фаза 7: Настройка Log Driven Development

По PCAM, логи — это основной инструмент тестирования и диагностики для ИИ.

### Микрошаг 7.1: Создать модуль логирования

Промпт для Cursor:

```
Режим: Code.

Создай модуль src/core/logging_config.py с настройкой логирования.

Контракт:
- PURPOSE: Централизованная настройка логирования для всего проекта
- ФОРМАТ ЛОГА: [LEVEL][ClassName][MethodName][StepName] Message
- ВЫВОД: в файл logs/app.log + консоль
- РОТАЦИЯ: по размеру (10MB), хранить 5 файлов
- УРОВНИ: DEBUG для разработки, INFO для продакшена

Пример строки лога:
[INFO][OrderService][create_order][ValidationComplete] Заказ #123 прошёл валидацию
[ERROR][OrderService][create_order][DBWrite] Ошибка записи в БД | IntegrityError: ...

Файл должен содержать полную GRACE-разметку.
```

### Микрошаг 7.2: Создать гайд по динамическому логированию

Файл `docs/dynamic_logging_heuristics.md`:

```markdown
# Гайд по динамическому логированию

## Когда использовать
Когда стандартных логов недостаточно для диагностики проблемы.

## Процесс
1. Определи подозрительный BLOCK в коде
2. Добавь временные логи ВНУТРИ блока:
   ```python
   logger.debug(f"[DEBUG][{self.__class__.__name__}][method][TempDiag] var={var}")
   ```
3. Попроси оператора воспроизвести проблему
4. Проанализируй логи
5. ОБЯЗАТЕЛЬНО удали временные логи после диагностики

## Что логировать
- Значения переменных на входе в блок
- Промежуточные результаты вычислений
- Условия ветвления (какая ветка if/else выполнилась)
- Содержимое ответов от внешних API

## Формат временных логов
Всегда используй маркер [TempDiag] для лёгкого поиска и удаления:
```python
logger.debug(f"[DEBUG][Class][Method][TempDiag] описание: {переменная}")
```
```

---

## 10. Фаза 8: Интеграция FLEX (если используются SLM)

Эта фаза применяется, если в проекте есть ИИ-агенты, работающие на локальных SLM (Qwen, Llama и т.д.).

### Микрошаг 8.1: Создать файл правил FLEX

Файл `.cursor/rules/rules-flex.md`:

```markdown
# Правила FLEX для SLM-агентов

## Когда применять
При создании промптов для локальных SLM-моделей (Qwen3-4B, Qwen3-14B и др.)

## Структура FLEX-промпта

### Обязательные блоки:
1. **<Tools>** — список доступных инструментов
2. **<Examples>** — примеры использования (few-shot)
3. **<UserQuery>** — запрос пользователя

### Формат описания инструмента:
```xml
<Tool>
  <Name>OrderCreate</Name>           <!-- Одно слово, один токен -->
  <Keywords>buy:9|purchase:9|order:8|create:7</Keywords>  <!-- Вес 1-9 -->
  <Trigger>Пользователь хочет создать новый заказ</Trigger>
  <Description>Создание нового заказа в системе</Description>
</Tool>
```

### Формат примера:
```xml
<Example>
  <UserQuery>Создай заказ на 100 единиц товара А</UserQuery>
  <SelectedTool>OrderCreate</SelectedTool>
  <Confidence>9</Confidence>
</Example>
```

## Правила создания FLEX-промптов:
1. Name инструмента — желательно один токен
2. Keywords — ключевые слова с весами от 1 до 9
3. Минимум 20 примеров, оптимально 30-50
4. Примеры должны покрывать edge-cases
5. Confidence — самооценка от 1 до 9
6. При Confidence < 5 — запросить уточнение у пользователя
```

### Микрошаг 8.2: Промпт для генерации FLEX-конфигурации агента

```
Режим: Architect.
Загрузи: @.cursor/rules/rules-flex.md

Задача: Создать FLEX-конфигурацию для ИИ-агента [название агента].

Агент имеет доступ к следующим инструментам:
1. [Инструмент 1] — [описание]
2. [Инструмент 2] — [описание]
...

Создай файл agents/[agent_name]_flex_config.xml с:
1. Блоком <Tools> — описание каждого инструмента
2. Блоком <Examples> — минимум 30 примеров (включая edge-cases)
3. Блоком <SystemPrompt> — инструкция для SLM
```

---

## 11. Чек-лист запуска нового проекта

Используйте этот чек-лист каждый раз при создании нового проекта:

### Фаза 0: Подготовка (вне Cursor)
- [ ] Цель проекта сформулирована одним предложением
- [ ] 3-5 бизнес-сценариев описаны
- [ ] Технический стек определён
- [ ] Границы MVP зафиксированы

### Фаза 1: Структура (в терминале)
- [ ] Папка проекта создана, git init выполнен
- [ ] Папка `.cursor/rules/` создана
- [ ] `docs/USER_PROFILE.xml` скопирован

### Фаза 2: Глобальные правила
- [ ] `.cursorrules` создан и заполнен
- [ ] Цель проекта вписана в .cursorrules
- [ ] Стандарты GRACE-разметки описаны
- [ ] Формат логирования описан

### Фаза 3: Правила режимов
- [ ] `rules-architect.md` создан
- [ ] `rules-code.md` создан
- [ ] `rules-debug.md` создан
- [ ] `rules-flex.md` создан (если нужны SLM)

### Фаза 4: Техническое задание
- [ ] `DEVELOPMENT_PLAN.md` создан и заполнен
- [ ] Фазы реализации определены
- [ ] Критерии завершения каждой фазы описаны

### Фаза 5: Первый запуск
- [ ] Cursor видит .cursorrules (проверено тестовым промптом)
- [ ] Архитектура спроектирована в режиме Architect
- [ ] Архитектура утверждена
- [ ] Скелет проекта сгенерирован в режиме Code
- [ ] Каждый файл проверен на наличие GRACE-разметки

### Фаза 6: Разметка
- [ ] Все файлы имеют MODULE_CONTRACT
- [ ] Все файлы имеют MODULE_MAP
- [ ] Все методы имеют CONTRACT
- [ ] Логические блоки обёрнуты в BLOCK
- [ ] KNOWLEDGE_GRAPH.xml создан

### Фаза 7: Логирование
- [ ] Модуль логирования настроен
- [ ] Формат лога: [LEVEL][Class][Method][Step]
- [ ] dynamic_logging_heuristics.md создан

### Фаза 8: FLEX (опционально)
- [ ] rules-flex.md создан
- [ ] FLEX-конфигурации агентов созданы
- [ ] Минимум 20 примеров на каждый инструмент

---

## Приложение A: Шаблоны всех файлов

### A.1: Шаблон .cursorrules

```
# === ГЛОБАЛЬНЫЕ ПРАВИЛА ПРОЕКТА ===

## Профиль оператора (PCAM)
[Скопировать из секции 4, микрошаг 2.1]

## Цель проекта (PCAM)
ЦЕЛЬ: [Одно предложение]

## Технический стек
[Список технологий]

## Стандарты кодирования (GRACE)
[Скопировать стандарты разметки из секции 4]

## Логирование (PCAM)
Формат: [LEVEL][Class][Method][Step] Message

## Контрактное программирование (PCAM)
Контракт пишется ДО кода.

## Запрещено
[Список запретов]
```

### A.2: Шаблон MODULE_CONTRACT

```python
# FILE: путь/к/файлу.py
# VERSION: 1.0.0
# START_MODULE_CONTRACT:
#   PURPOSE: [Зачем существует этот модуль]
#   SCOPE: [Ключевые слова]
#   DEPENDENCIES: [Зависимости]
# END_MODULE_CONTRACT

# START_MODULE_MAP:
#   CLASS => ClassName
#     METHOD 1 [Описание] => method_name
#     METHOD 2 [Описание] => method_name
# END_MODULE_MAP
```

### A.3: Шаблон CONTRACT метода

```python
# START_CONTRACT:
#   PURPOSE: [Что делает]
#   INPUTS: [Что принимает]
#   OUTPUTS: [Что возвращает]
#   SIDE_EFFECTS: [Побочные эффекты]
# END_CONTRACT
def method_name(self, param1: Type, param2: Type) -> ReturnType:
```

### A.4: Шаблон BLOCK-разметки

```python
# START_BLOCK_НАЗВАНИЕ_БЛОКА: [Краткое описание]
...код блока...
# END_BLOCK_НАЗВАНИЕ_БЛОКА
```

### A.5: Шаблон строки лога

```python
logger.info(f"[INFO][{self.__class__.__name__}][method_name][StepName] Описание действия")
logger.error(f"[ERROR][{self.__class__.__name__}][method_name][StepName] Описание ошибки | {error}")
logger.debug(f"[DEBUG][{self.__class__.__name__}][method_name][TempDiag] var={var}")
```

### A.6: Шаблон CHANGE_SUMMARY

```python
# START_CHANGE_SUMMARY:
#   LAST_CHANGE: 2026-02-12 — Описание последнего изменения
#   PREVIOUS: 2026-02-10 — Описание предыдущего изменения
# END_CHANGE_SUMMARY
```

### A.7: Шаблон FLEX Tool

```xml
<Tool>
  <Name>ToolName</Name>
  <Keywords>keyword1:9|keyword2:8|keyword3:7</Keywords>
  <Trigger>Условие вызова на естественном языке</Trigger>
  <Description>Описание функциональности</Description>
</Tool>
```

---

## Приложение B: Готовые промпты для каждой фазы

### B.1: Промпт проверки настройки

```
Прочитай .cursorrules и подтверди, что понимаешь:
1. Кто оператор и какие у него предпочтения
2. Какая цель проекта
3. Какие стандарты разметки кода
4. Какой формат логирования
Перечисли всё кратко.
```

### B.2: Промпт для режима Architect (новый модуль)

```
Режим: Architect.
Загрузи: @docs/DEVELOPMENT_PLAN.md @docs/USER_PROFILE.xml

Задача: Спроектировать модуль [название].
Бизнес-сценарий: [описание сценария]

Следуй плейбуку из @.cursor/rules/rules-architect.md.
Результат: MODULE_CONTRACT + список методов с CONTRACT.
НЕ ПИШИ КОД.
```

### B.3: Промпт для режима Code (реализация модуля)

```
Режим: Code.
Загрузи: @.cursor/rules/rules-code.md

Задача: Реализовать модуль [название] по утверждённому контракту.
Контракт: [вставить или сослаться на файл]

Следуй плейбуку. Создай файл с полной GRACE-разметкой.
Один файл за раз, жди подтверждения.
```

### B.4: Промпт для режима Debug

```
Режим: Debug.
Загрузи: @.cursor/rules/rules-debug.md @docs/dynamic_logging_heuristics.md

Проблема: [описание ошибки]
Лог: [вставить релевантные строки лога]

Следуй плейбуку. Начни с анализа и гипотез.
НЕ ИСПРАВЛЯЙ сразу — сначала подтверди диагноз.
```

### B.5: Промпт для добавления GRACE-разметки к существующему файлу

```
Прочитай файл @[путь/к/файлу]
Добавь полную GRACE-разметку:
1. MODULE_CONTRACT в начало
2. MODULE_MAP после контракта
3. CONTRACT для каждого метода
4. BLOCK-разметку для логических блоков (>10 строк)
5. Логирование в формате [LEVEL][Class][Method][Step]

НЕ МЕНЯЙ существующую логику. Только разметка и логирование.
```

### B.6: Промпт для обновления KNOWLEDGE_GRAPH

```
Режим: Architect.

Прочитай все файлы в src/ и обнови @docs/KNOWLEDGE_GRAPH.xml:
- Добавь новые модули/классы/методы
- Обнови CrossLinks (связи между модулями)
- Обнови keywords и annotations
```

### B.7: Промпт для ежедневного начала работы

```
Загрузи: @docs/DEVELOPMENT_PLAN.md

Какая сейчас текущая фаза? Какие задачи не завершены?
Предложи план работы на сегодня (3-5 микрозадач).
```


---

## Часть 2: Практический запуск проекта

На этом этапе мы переходим от теории к практике. Мы создадим артефакты, которые станут фундаментом для работы Cursor. Главная цель — дать ИИ-ассистенту максимально чёткий, структурированный и непротиворечивый контекст.

### Шаг 3: Создание Технического Задания (ТЗ) в формате PCAM

Техническое задание — это главный документ, описывающий проект. Мы создадим его в файле `PROJECT_BRIEF.md` в корне проекта. Этот файл будет использовать методологию PCAM для структурирования информации.

**Микрошаги:**

1.  **Создайте файл `PROJECT_BRIEF.md`** в корне вашего нового проекта.
2.  **Заполните его по следующей структуре**, адаптируя под ваш проект. Ниже приведен пример для гипотетического проекта "AI-ассистент для управления задачами".

```markdown
# Техническое Задание: AI-ассистент для управления задачами

## 1. Purpose (Цель)

- **Основная цель:** Создать веб-приложение на Django, которое поможет пользователям управлять задачами с помощью AI-ассистента. Ассистент должен уметь создавать, классифицировать, приоритизировать задачи и предлагать следующие шаги на основе их содержания.
- **Бизнес-цели:** Увеличить продуктивность пользователей на 20%, сократить время на ручное управление задачами. MVP должен быть готов через 2 месяца.
- **Пользовательские цели:** Получить простой инструмент для организации своих дел, где ИИ берет на себя рутину.

## 2. Context (Контекст)

- **Пользователи:** Фрилансеры, менеджеры проектов, разработчики (как Роман).
- **Технические ограничения:** Стек Django + PostgreSQL/SQLite. Развертывание на Alibaba Cloud. Docker не использовать. Модель ИИ — GPT-5.3 Codex через API OpenAI.
- **Внешние системы:** Интеграция с API OpenAI. В будущем возможна интеграция с Google Calendar.
- **Ключевые документы:** `@USER_PROFILE.xml`, `@./.rules/grace.md`, `@./.rules/flex.xml`.

## 3. Audience (Аудитория)

- **Основная аудитория:** Технически подкованные пользователи, знакомые с IDE (Cursor) и принципами работы с ИИ. Общение на "ты".
- **Стиль общения:** Профессиональный, но не формальный. Ответы должны быть развернутыми, с объяснениями и микрошагами.
- **Предпочтения:** ИИ должен задавать уточняющие вопросы, предлагать архитектурные решения, генерировать код и документацию.

## 4. Medium (Носитель)

- **Основная платформа:** Cursor IDE.
- **Формат вывода:** Код на Python/JavaScript, текстовые файлы в Markdown, ответы в чате Cursor.
- **Структура кода:** Использовать GRACE-разметку (MODULE_CONTRACT, BLOCK и т.д.) для навигации и понимания. Комментарии должны быть подробными.
- **Патчи и изменения:** Применять изменения детерминированно, используя `diff` формат, как описано в GRACE.
```

### Шаг 4: Создание первого промпта для инициализации проекта

Теперь, когда все артефакты на месте, мы можем дать Cursor первую команду. Этот промпт запустит процесс создания структуры проекта.

**Микрошаги:**

1.  **Откройте чат в Cursor**.
2.  **Убедитесь, что все созданные файлы (`USER_PROFILE.xml`, `grace.md`, `flex.xml`, `PROJECT_BRIEF.md`) видны** в дереве проекта.
3.  **Сформулируйте и отправьте следующий промпт**:

```
Привет! Мы начинаем новый проект. Пожалуйста, внимательно изучи следующие файлы, чтобы полностью понять контекст, мои предпочтения и правила работы:

1. `@USER_PROFILE.xml` — мой профиль, стек и стиль.
2. `@PROJECT_BRIEF.md` — техническое задание на проект по методологии PCAM.
3. `@./.rules/grace.md` — правила семантической разметки кода.
4. `@./.rules/flex.xml` — правила выбора инструментов и функций.

Твоя первая задача — создать базовую структуру Django-проекта согласно моим предпочтениям из `USER_PROFILE.xml` и ТЗ из `PROJECT_BRIEF.md`.

Действуй по микрошагам:

1.  Создай виртуальное окружение `.venv`.
2.  Активируй его и установи Django.
3.  Создай новый Django-проект с именем `config`.
4.  Создай первое приложение с именем `core`.
5.  Внеси `core` в `INSTALLED_APPS` в `config/settings.py`.

После каждого шага дожидайся моего подтверждения. Начнем с шага 1.
```

### Шаг 5: Пошаговое выполнение и контроль

Это самый важный этап, где вы направляете ИИ.

-   **Контроль:** После каждого ответа Cursor проверяйте, что он выполнил задачу корректно и в соответствии с вашими правилами. Если он отклонился, мягко поправьте его, сославшись на один из ваших артефактов. Например: *"Отлично, но давай использовать `snake_case` для переменных, как указано в `USER_PROFILE.xml`."*
-   **Микрошаги:** Настаивайте на выполнении работы по микрошагам. Это ваш главный инструмент контроля. Не позволяйте ИИ генерировать большие объемы кода за раз на начальном этапе.
-   **GRACE-разметка:** С самого первого файла требуйте применения GRACE-разметки. Например, после создания `models.py`, попросите его добавить `MODULE_CONTRACT`.

**Пример следующего промпта после создания структуры:**

```
Отлично, структура создана. Теперь перейдем к приложению `core`.

Задача: создать первую модель `Task` в `core/models.py`.

Действуй по микрошагам:

1.  Открой файл `core/models.py`.
2.  Добавь в начало файла `MODULE_CONTRACT` согласно правилам из `grace.md`. Опиши, что этот модуль будет содержать основные модели данных для всего проекта.
3.  Создай класс `Task`, унаследованный от `models.Model`, с полями: `title` (CharField), `description` (TextField), `created_at` (DateTimeField, auto_now_add=True).
4.  Добавь `BLOCK` с описанием назначения модели `Task`.
```

Этот подход превращает разработку из хаотичного процесса в управляемый и предсказуемый инжиниринг. Вы не просто просите "сделать", вы учите ИИ "как делать" в рамках вашей системы координат.


---

## Часть 3: Чек-листы и шаблоны для ежедневной работы

Эта часть — ваш инструментарий на каждый день. Она поможет поддерживать порядок в проекте и обеспечивать стабильное качество работы с ИИ.

### Чек-лист для старта нового проекта

Используйте этот чек-лист каждый раз, когда начинаете новый проект с нуля.

-   [ ] 1. Создана корневая папка проекта.
-   [ ] 2. В корне создан файл `USER_PROFILE.xml` (можно скопировать из другого проекта).
-   [ ] 3. В корне создана папка `.rules`.
-   [ ] 4. В `.rules` скопированы файлы `grace.md` и `flex.xml`.
-   [ ] 5. В корне создан файл `PROJECT_BRIEF.md` и заполнен по методологии PCAM.
-   [ ] 6. Отправлен первый промпт в Cursor с подключением всех 4-х артефактов (`@USER_PROFILE.xml`, `@PROJECT_BRIEF.md`, `@./.rules/grace.md`, `@./.rules/flex.xml`).
-   [ ] 7. Проверено, что ИИ понял задачу и начал действовать по микрошагам.

### Шаблон файла `grace.md`

Этот файл должен лежать в `.rules/grace.md`. Он объясняет ИИ, как использовать семантическую разметку.

```markdown
# Принципы семантической разметки кода (GRACE)

Этот документ определяет правила разметки кода для улучшения его понимания и навигации. Используй эти правила во всех файлах.

## 1. Контракт Модуля (`MODULE_CONTRACT`)

-   **Назначение:** Описывает зону ответственности модуля (файла).
-   **Формат:** Комментарий в начале файла.
-   **Пример:**
    ```python
    # MODULE_CONTRACT
    # Ответственность: Управление моделями данных, связанными с пользователями.
    # Включает модели User, Profile, и связанные с ними менеджеры.
    ```

## 2. Карта Модуля (`MODULE_MAP`)

-   **Назначение:** Оглавление файла, перечисление ключевых блоков.
-   **Формат:** Комментарий после `MODULE_CONTRACT`.
-   **Пример:**
    ```python
    # MODULE_MAP
    # 1. Imports
    # 2. Models
    #    - UserProfile
    #    - UserActivity
    # 3. Managers
    #    - UserActivityManager
    ```

## 3. Логический Блок (`BLOCK`)

-   **Назначение:** Описание назначения конкретного класса, функции или логического сегмента кода.
-   **Формат:** Комментарий перед классом или функцией.
-   **Пример:**
    ```python
    # BLOCK
    # Назначение: Модель для хранения расширенной информации о пользователе.
    class UserProfile(models.Model):
        # ...
    ```

## 4. Токены Мышления (`THINKING_TOKENS`)

-   **Назначение:** Используется для описания твоих мыслей, плана действий, гипотез перед генерацией или рефакторингом кода.
-   **Формат:** Комментарий в том месте, где будет происходить изменение.
-   **Пример:**
    ```python
    # THINKING_TOKENS
    # План:
    # 1. Добавить поле `last_login` в модель UserProfile.
    # 2. Поле должно быть `DateTimeField` с `null=True`, `blank=True`.
    # 3. После добавления поля нужно будет создать и применить миграции.
    # --- Код ниже будет изменен ---
    ```

## 5. Детерминированные патчи (`diff`)

-   **Назначение:** Когда ты предлагаешь изменения в существующем коде, всегда используй формат `diff` для ясности.
-   **Формат:**
    ```diff
    --- a/file.py
    +++ b/file.py
    @@ -1,5 +1,6 @@
     class User:
         def __init__(self, name):
             self.name = name
+            self.email = None # Новое добавленное поле
    
    ```
```

### Шаблон файла `flex.xml`

Этот файл должен лежать в `.rules/flex.xml`. Он помогает ИИ выбирать правильные инструменты.

```xml
<!-- Методология FLEX для выбора инструментов -->
<FLEX>
    <Tools>
        <Tool name="create_file">
            <Description>Создает новый файл с указанным содержимым.</Description>
            <Example>Создай файл `core/services.py` с контрактом модуля.</Example>
        </Tool>
        <Tool name="edit_code">
            <Description>Редактирует существующий код, применяя патч.</Description>
            <Example>Добавь поле `email` в модель `UserProfile`.</Example>
        </Tool>
        <Tool name="run_shell_command">
            <Description>Выполняет команду в терминале.</Description>
            <Example>Выполни команду `python manage.py migrate`.</Example>
        </Tool>
    </Tools>

    <Keywords>
        <Keyword for="create_file">создай файл, новый файл</Keyword>
        <Keyword for="edit_code">измени, добавь, удали, рефакторинг</Keyword>
        <Keyword for="run_shell_command">выполни, команда, запусти</Keyword>
    </Keywords>

    <Trigger>
        <Condition>Когда я прошу выполнить действие с кодом или файловой системой, выбери один из инструментов выше.</Condition>
        <Action>Перед выполнением, сообщи, какой инструмент ты выбрал и с какой уверенностью (Confidence: 0-100%).</Action>
    </Trigger>

    <Examples>
        <Example>
            <UserInput>Создай `views.py` в `core`</UserInput>
            <AIOutput>
                <Thought>Пользователь хочет создать файл. Наиболее подходящий инструмент — `create_file`.</Thought>
                <ToolSelection>
                    <Name>create_file</Name>
                    <Confidence>100%</Confidence>
                </ToolSelection>
            </AIOutput>
        </Example>
    </Examples>
</FLEX>
```

---

## Часть 9: Специализированные ИИ-системы

Универсальный шаблон выше покрывает общий случай любого Django-проекта. Однако для создания специализированных ИИ-систем требуются дополнительные архитектурные паттерны, компоненты и подходы к тестированию. Подробное руководство по 5 типам таких систем вынесено в отдельный документ:

> **Смотрите файл `specialized_systems_guide.md`** — полное руководство по проектированию:
> 1. **RLHF-платформ** — сбор человеческих предпочтений и дообучение моделей
> 2. **СППР на базе ИИ** — интеллектуальные системы поддержки принятия решений с RAG
> 3. **ИИ-агентов** — автономные агенты с инструментами и памятью (паттерн ReAct)
> 4. **Мультиагентных систем** — команды агентов с оркестрацией (CrewAI, LangChain, AutoGen)
> 5. **Простых ИИ-инструментов** — узкоспециализированные утилиты (удаление фона, транскрибация)

Каждый раздел включает архитектуру, структуру проекта, микрошаги реализации, примеры кода, промпты для Cursor и подходы к тестированию.

---

## Часть 10: Автоматизированные рабочие места (АРМ)

Для создания корпоративных АРМ — систем, которые объединяют справочники, бизнес-процессы, контроль, автоматизацию и ИИ в едином интерфейсе — подготовлено отдельное руководство:

> **Смотрите файл `arm_guide.md`** — полное руководство по проектированию АРМ:
> 1. **Справочники** — управление НСИ, иерархические структуры (`django-mptt`), импорт/экспорт
> 2. **Процессы** — конечные автоматы (`django-fsm`), жизненные циклы документов
> 3. **Контроль результата** — аудит действий, дашборды, KPI, генерация отчётов
> 4. **Автоматизация** — Celery Beat, Webhooks, интеграция с N8n
> 5. **ИИ** — встроенный ИИ-ассистент (Copilot), RAG по базе знаний, умный поиск

Каждый раздел включает архитектуру, структуру проекта, микрошаги реализации, примеры кода и промпты для Cursor.

---

## Часть 11: Опросник для спецификации нового проекта

Перед началом любого нового проекта рекомендуется заполнить структурированный опросник, который позволит собрать всю необходимую информацию для формирования полной проектной документации.

> **Смотрите файл `project_questionnaire.md`** — полный перечень вопросов по 10 блокам:
> 1. **Видение и цели** — цель проекта, проблема, KPI, границы MVP
> 2. **Бизнес-логика** — сценарии использования, сущности, бизнес-правила, жизненные циклы
> 3. **Пользователи и роли** — роли, права доступа, профиль оператора ИИ
> 4. **Архитектура** — стек, архитектурный стиль, библиотеки, ограничения
> 5. **Данные и модели** — поля сущностей, типы данных, связи между моделями
> 6. **API и интеграции** — эндпоинты, внешние сервисы, аутентификация, webhooks
> 7. **Искусственный интеллект** — провайдеры LLM, сценарии ИИ, RAG, агенты
> 8. **Автоматизация** — фоновые задачи, расписание, N8n-воркфлоу
> 9. **Контроль и мониторинг** — аудит, дашборды, отчёты, логирование
> 10. **Инфраструктура** — облако, ОС, CI/CD, зависимости, среда разработки

Опросник включает примеры ответов и таблицу маппинга ответов на конкретные артефакты проекта (файлы и модули).

---

## Часть 12: Тестирование Django-проектов с ИИ

Тестирование — критически важная часть разработки, которая обеспечивает качество и стабильность кода. С ИИ-ассистентом процесс тестирования можно значительно ускорить, используя подход AI-Assisted TDD.

> **Смотрите файл `testing_guide.md`** — полное руководство по тестированию:
> 1. **Философия AI-Assisted TDD** — адаптация цикла "Красный → Зелёный → Рефакторинг" для работы с ИИ
> 2. **Unit-тесты** — тестирование моделей, сервисов и бизнес-логики в изоляции
> 3. **Integration-тесты** — тестирование views, API (DRF) и фоновых задач (Celery)
> 4. **E2E-тесты** — сквозные сценарии пользователя через Selenium
> 5. **Тестирование ИИ-компонентов** — промпты, RAG-системы, агенты
> 6. **Промпты для генерации тестов** — готовые шаблоны для Cursor

---

## Часть 13: Безопасность Django-проектов

Безопасность — это не разовое мероприятие, а непрерывный процесс. ИИ-ассистент помогает проактивно искать уязвимости и генерировать безопасные конфигурации.

> **Смотрите файл `security_guide.md`** — полное руководство по безопасности:
> 1. **Security as Code** — автоматизация задач безопасности с ИИ
> 2. **Управление секретами** — `python-decouple`, `.env`, `.gitignore`
> 3. **Чек-лист безопасности Django** — конфигурация, аутентификация, защита данных
> 4. **OWASP Top 10 в контексте Django** — таблица уязвимостей с промптами для Cursor
> 5. **Промпты для Security Review** — аудит, проверка зависимостей, настройки

---

## Часть 14: Библиотека готовых промптов для Cursor

Вместо того чтобы каждый раз придумывать промпт с нуля, используйте каталог проверенных шаблонов для типовых задач.

> **Смотрите файл `prompt_library.md`** — единый каталог промптов по 7 категориям:
> 1. **Архитектура и планирование** — старт проекта, ежедневное планирование
> 2. **CRUD** — генерация моделей, views, форм, шаблонов
> 3. **API (DRF)** — сериализаторы, ViewSet, роутеры
> 4. **Тестирование** — unit-тесты, integration-тесты для API
> 5. **Рефакторинг** — GRACE-разметка, улучшение кода
> 6. **Искусственный интеллект** — создание агентов, RAG
> 7. **Безопасность** — аудит по OWASP Top 10

---

## Часть 15: Сквозная наблюдаемость (Observability)

При разработке больших систем (АРМ, мультиагентные системы, ИИ-пайплайны) критически важно видеть вход и выход на каждом этапе преобразования данных. Это позволяет быстро находить место, где качество результата падает.

> **Смотрите файл `observability_guide.md`** — полное руководство по визуальной наблюдаемости:
> 1. **Философия: от логов к визуальному контролю** — почему нужно видеть данные глазами, а не читать логи
> 2. **Уровень 1: Django Admin** — модели `PipelineTrace`/`PipelineStep`, декоратор `@record_step`, визуализация JSON вход/выход в админке
> 3. **Уровень 2: Django Debug Toolbar** — SQL, запросы, шаблоны, кэш — всё в панели на странице
> 4. **Уровень 3: Langfuse UI** — дерево вызовов RAG/LLM с фактическими промптами и ответами
> 5. **Уровень 4: Мультиагенты** — граф выполнения агента, траектория мыслей, вход/выход каждого шага
> 6. **Промпты для Cursor** — готовые шаблоны для внедрения визуального контроля
> 7. **Чек-лист** — 14 пунктов проверки визуальной наблюдаемости

---

## Заключение

Этот универсальный шаблон — ваша система координат для работы с ИИ в Cursor. Он превращает процесс разработки из набора случайных промптов в структурированный и управляемый инжиниринг. Ключ к успеху — **последовательность и дисциплина**. Всегда используйте эти артефакты, требуйте от ИИ их соблюдения, и вы получите предсказуемый и качественный результат.
