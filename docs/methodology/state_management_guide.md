# Гайд: Автоматическое отслеживание состояния проекта в Cursor

## Введение

Этот гайд решает фундаментальную проблему работы с ИИ в Cursor — потерю контекста между сессиями. Ваш текущий подход с "миграционными промптами" — это шаг в верном направлении, но он приводит к ручному труду, дублированию информации и быстрому заполнению контекстного окна LLM.

Проанализировав 19 ваших миграционных файлов и изучив лучшие практики сообщества (такие как Memory Bank и CLAUDE.md), я предлагаю перейти на автоматизированную систему, которая будет поддерживать актуальное состояние проекта без ручного вмешательства.

## 1. Анализ вашего текущего подхода

Ваши `migration_XX.md` файлы — это структурированный лог изменений. Это хорошо, но у подхода есть 5 ключевых проблем:

| Проблема | Описание |
|---|---|
| **1. Линейный рост объёма** | Каждый новый файл длиннее предыдущего, так как дублирует информацию о состоянии. К 19-й сессии LLM должна прочитать тысячи строк, чтобы понять контекст. |
| **2. Дублирование информации** | Таблица миграций и ключевые решения копируются из сессии в сессию. Это избыточно. |
| **3. Ручной труд** | Вы вручную пишете каждый файл после сессии. Если забыть — контекст теряется. |
| **4. Нет единого состояния** | Чтобы понять текущее состояние проекта, нужно прочитать все 19 файлов по порядку. Нет одного файла, который бы описывал "проект сейчас". |
| **5. Переполнение контекстного окна** | Большой объём миграционных файлов быстро заполняет контекстное окно Cursor, и LLM начинает "забывать" ранние решения. |

## 2. Архитектура нового решения: "Живая документация"

Вместо N миграционных файлов мы создадим 3 ключевых артефакта, которые будут обновляться автоматически. Это подход, вдохновлённый фреймворком **Memory Bank**.

| Файл | Назначение | Как обновляется |
|---|---|---|
| **`PROJECT_STATE.md`** | **Единственный источник правды.** Описывает текущее состояние проекта. | **Перезаписывается** в конце каждой сессии. |
| **`SESSION_LOG.md`** | **Журнал изменений (дельта).** Краткая запись того, *что* было сделано в сессии. | **Дополняется (append)** в конце каждой сессии. |
| **`DECISIONS.md`** | **Журнал архитектурных решений.** Запись *почему* было принято то или иное важное решение. | **Дополняется (append)**, когда принимается важное решение. |

**Преимущества:**
- **Экономия токенов:** В начале новой сессии LLM читает только один `PROJECT_STATE.md`, а не 19+ файлов.
- **Актуальность:** `PROJECT_STATE.md` всегда актуален.
- **Автоматизация:** LLM сама обновляет эти файлы по специальному правилу.
- **История:** `SESSION_LOG.md` и `DECISIONS.md` сохраняют полную хронологию проекта для анализа.

## 3. Автоматический файл состояния: `PROJECT_STATE.md`

Это сердце новой системы. Он должен генерироваться автоматически и содержать полную, но сжатую информацию о проекте. LLM будет использовать его как основной источник контекста.

### Структура `PROJECT_STATE.md`

```markdown
# Project State: [Название проекта]

*Последнее обновление: YYYY-MM-DD HH:MM*

## 1. Ключевые цели и KPI

- **Цель:** [Цель проекта из Elevator Pitch]
- **Проблема:** [Проблема, которую решаем, по методу 5 Whys]
- **KPI:** [Ключевые метрики по SMART]

## 2. Архитектура и стек

- **Стек:** Django, DRF, Celery, PostgreSQL, React, Nginx, Docker
- **Архитектурный стиль:** Монолит с модульной структурой, асинхронные задачи через Celery.
- **Ключевые библиотеки:** `django-fsm`, `django-mptt`, `langfuse`, `crewai`.

## 3. Структура проекта (файлы)

```
[Вывод команды `tree -L 3 -I "__pycache__|*.pyc|migrations"`]
```

## 4. Модели данных (Django Models)

| Приложение | Модель | Ключевые поля |
|---|---|---|
| `procurement` | `Supplier` | `name`, `country`, `supplier_type`, `metadata` |
| `procurement` | `ManufacturerCandidate` | `name`, `status`, `source`, `ai_confidence` |
| `users` | `User` | `email`, `role` |

## 5. Ключевые API Endpoints

| Метод | URL | Назначение |
|---|---|---|
| POST | `/api/vendor-ingest/run/` | Запуск процесса ingest'а поставщиков |
| GET | `/api/manufacturer-candidates/` | Получение списка кандидатов в производители |

## 6. Статус миграций Django

```
[Вывод команды `python manage.py showmigrations procurement users --plan`]
```

## 7. Ключевые принятые решения

*Последние 5 решений из `DECISIONS.md`*

1.  **[Дата]:** Используем staging-модель `ManufacturerCandidate` вместо прямой записи в `Supplier` для контроля качества.
2.  **[Дата]:** Для наблюдаемости ИИ-пайплайнов используем Langfuse UI.
3.  ...

## 8. Текущие задачи и TODO

- [ ] Добавить автотесты для `vendor-ingest`.
- [ ] Усилить валидацию загружаемых файлов.
- [ ] Добавить UI-индикатор confidence для required-полей.
```

## 4. Промпты для автоматизации

Ключ к автоматизации — это стандартизированные промпты, которые вы даёте LLM в определённые моменты сессии. Главный из них — промпт в конце сессии.

### Промпт "Завершение сессии и обновление состояния"

Этот промпт вы даёте в конце каждой рабочей сессии в Cursor. LLM выполнит его, чтобы обновить все артефакты состояния.

> **Промпт:**
> 
> Завершаем сессию. Обнови состояние проекта, следуя этому алгоритму:
> 
> 1.  **Собери информацию о текущем состоянии:**
>     *   Выполни команду `tree -L 3 -I "__pycache__|*.pyc|migrations|.*"` в корне проекта, чтобы получить актуальную структуру файлов.
>     *   Выполни команду `python manage.py showmigrations procurement users --plan`, чтобы получить статус миграций.
>     *   Прочитай файл `DECISIONS.md` и возьми последние 5 записей.
>     *   Прочитай раздел "Текущие задачи и TODO" из `PROJECT_STATE.md`.
> 
> 2.  **Сгенерируй и запиши новый `PROJECT_STATE.md`:**
>     *   Используй шаблон из `state_management_guide.md`.
>     *   Полностью перезапиши файл `PROJECT_STATE.md` свежими данными, которые ты собрал на шаге 1.
>     *   Вставь актуальную дату и время в заголовок.
> 
> 3.  **Сгенерируй и добавь запись в `SESSION_LOG.md`:**
>     *   На основе нашей переписки в этой сессии, напиши краткое summary (2-3 предложения) о том, что было сделано.
>     *   Добавь эту запись в конец файла `SESSION_LOG.md` в формате:
>         ```markdown
>         ### Сессия YYYY-MM-DD HH:MM
>         
>         - [Краткое описание сделанного]
>         - [Ключевое принятое решение, если было]
>         ```
> 
> 4.  **Подтверди завершение:**
>     *   Сообщи мне, что обновление состояния завершено.

### Промпт "Запись архитектурного решения"

Этот промпт вы используете в середине сессии, когда принимаете важное решение.

> **Промпт:**
> 
> Записываем архитектурное решение. Добавь следующую информацию в конец файла `DECISIONS.md`:
> 
> - **Дата:** [сегодняшняя дата]
> - **Решение:** [Суть решения. Например: "Используем staging-модель `ManufacturerCandidate` вместо прямой записи в `Supplier`"]
> - **Причина:** [Обоснование. Например: "Для контроля качества данных и предотвращения загрязнения основной таблицы `Supplier`"]

## 5. Правило для `.cursorrules`

Чтобы LLM *всегда* помнила о необходимости обновлять состояние, мы добавим правило в `.cursorrules`.

```json
{
  "rules": [
    {
      "name": "StateUpdateOnSessionEnd",
      "prompt": "В конце каждой сессии, когда пользователь даёт команду на завершение, я ОБЯЗАН предложить ему запустить процесс обновления состояния проекта. Я должен напомнить ему использовать промпт \"Завершение сессии и обновление состояния\", чтобы я мог обновить файлы `PROJECT_STATE.md` и `SESSION_LOG.md`. Я не должен завершать работу, пока состояние не будет сохранено."
    }
  ]
}
```

Это правило будет мягко напоминать LLM (и вам) о необходимости выполнить ритуал сохранения состояния в конце работы.

## 6. Чек-лист по внедрению системы

Переход на новую систему займёт около 15 минут. Следуйте этому чек-листу:

1.  **[ ] Создайте файлы:**
    *   В корне вашего проекта создайте три пустых файла:
        *   `PROJECT_STATE.md`
        *   `SESSION_LOG.md`
        *   `DECISIONS.md`

2.  **[ ] Сделайте первичную генерацию `PROJECT_STATE.md`:**
    *   Откройте новую сессию в Cursor.
    *   Дайте LLM промпт "Завершение сессии и обновление состояния" (из раздела 4).
    *   Так как `DECISIONS.md` и `SESSION_LOG.md` пока пустые, LLM заполнит `PROJECT_STATE.md` на основе текущей структуры проекта. Проверьте, что файл сгенерировался корректно.

3.  **[ ] Создайте `.cursorrules`:**
    *   В папке `.cursor` вашего проекта создайте файл `rules.json` (если его нет).
    *   Скопируйте в него правило `StateUpdateOnSessionEnd` из раздела 5.

4.  **[ ] Перенесите ключевые решения:**
    *   Просмотрите ваши старые `migration_XX.md` файлы.
    *   Самые важные решения из таблиц "Decisions Made" скопируйте в `DECISIONS.md` с помощью промпта "Запись архитектурного решения". Не нужно переносить всё, только то, что влияет на архитектуру в целом.

5.  **[ ] Архивируйте старые миграции:**
    *   Создайте папку `docs/archive/migration_prompts/`.
    *   Переместите все ваши `migration_XX.md` файлы в эту папку, чтобы они не мешали и не попадали в контекст.

**Готово!** Теперь в начале каждой новой сессии просто добавляйте в контекст (`@`) файл `PROJECT_STATE.md`. В конце сессии используйте промпт для обновления, и ваш контекст всегда будет актуальным.
