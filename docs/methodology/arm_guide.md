# Приложение 2: Проектирование Автоматизированных Рабочих Мест (АРМ)

Это приложение к универсальному шаблону описывает архитектурные паттерны и конкретные шаги для создания сложных корпоративных систем класса АРМ на базе Django. АРМ — это не просто CRUD-интерфейс, а интегрированная среда, которая автоматизирует рутинные операции, управляет сложными бизнес-процессами и помогает пользователю принимать решения.

Мы рассмотрим АРМ как систему, состоящую из 5 ключевых модулей.

---

## Раздел 1: Справочники (Master Data Management)

Справочники — это фундамент любого АРМ. Это нормативно-справочная информация (НСИ), которая используется во всех бизнес-процессах: организационная структура, список сотрудников, перечень услуг, статусы документов и т.д. Ошибки в справочниках приводят к ошибкам во всей системе.

### 1.1. Архитектура модуля справочников

Основной принцип — **централизация и консистентность**. Вся НСИ должна управляться из одного места. В Django для этого идеально подходит встроенная админ-панель, расширенная дополнительными инструментами.

| Компонент | Технология | Назначение |
|---|---|---|
| **Хранилище данных** | PostgreSQL | Обеспечение целостности данных на уровне БД (constraints, foreign keys). |
| **Управление данными** | Django Admin | Централизованный интерфейс для CRUD-операций со справочниками. |
| **Импорт/Экспорт** | `django-import-export` | Инструмент для массовой загрузки и выгрузки данных в форматах CSV, XLSX. |
| **Иерархические данные** | `django-mptt` | Управление древовидными структурами (например, оргструктура компании). |

### 1.2. Структура Django-проекта

Рекомендуется выделить всю работу со справочниками в отдельное приложение `references`.

```
my_project/
├── ...
├── references/  <-- Новое приложение
│   ├── __init__.py
│   ├── models.py      # Модели для каждого справочника (Department, Employee, etc.)
│   ├── admin.py       # Кастомизация отображения в админ-панели
│   └── ...
├── ...
```

### 1.3. Микрошаги по реализации

1.  **Создание модели:** Определите модель для справочника. Например, для иерархического справочника подразделений.
2.  **Интеграция `django-mptt`:** Унаследуйте модель от `MPTTModel`.
3.  **Кастомизация админки:** Зарегистрируйте модель в `admin.py` и используйте `DraggableMPTTAdmin` для наглядного отображения дерева.
4.  **Создание промпта для Cursor (режим Архитектора):**

    ```markdown
    @USER_PROFILE.xml
    @rules/grace.md

    **Контекст:** Мы создаём модуль управления справочниками в приложении `references`.

    **Задача:** Спроектируй модель `Department` для хранения оргструктуры в `references/models.py`. Модель должна поддерживать иерархию (вложенные подразделения). Также подготовь код для `references/admin.py`, чтобы отобразить эту модель в виде интерактивного дерева.

    **План (PCAM):**
    - **Purpose:** Создать модель и административный интерфейс для управления иерархическим справочником.
    - **Context:** Django, `django-mptt`.
    - **Audience:** Я, разработчик.
    - **Medium:** Код в `references/models.py` и `references/admin.py`.

    **THINKING_TOKENS:**
    - Для иерархии лучше всего подходит `django-mptt`.
    - Модель `Department` должна наследоваться от `MPTTModel`.
    - В `admin.py` нужно использовать `DraggableMPTTAdmin` для удобного drag-and-drop управления структурой.
    ```

---

## Раздел 2: Процессы (Workflow Management)

Процессы — это сердце АРМ. Это последовательность действий, которые должен выполнить пользователь для достижения бизнес-результата (например, согласование договора, обработка заявки). Управление процессами через простые поля `status` быстро становится неконтролируемым. Правильный подход — использование конечных автоматов (Finite State Machine, FSM).

### 2.1. Архитектура модуля процессов

Архитектура строится вокруг модели, её состояний и переходов между ними.

| Компонент | Технология | Назначение |
|---|---|---|
| **Движок состояний** | `django-fsm` | Декларативное описание состояний и переходов для любой Django-модели. |
| **Модель процесса** | Django Model | Основная сущность, которая проходит через процесс (например, `Document`, `Order`). |
| **Триггеры переходов** | Python-функции | Действия, которые инициируют переход из одного состояния в другое. |
| **Побочные эффекты** | Signals / Callbacks | Логика, которая выполняется при успешном переходе (например, отправка уведомления). |

### 2.2. Структура Django-проекта

Логика FSM встраивается непосредственно в модели, которые участвуют в процессе (например, в приложение `documents`).

```python
# documents/models.py
from django.db import models
from django_fsm import FSMField, transition

class Document(models.Model):
    STATE_NEW = 'new'
    STATE_AGREEMENT = 'agreement'
    STATE_APPROVED = 'approved'
    STATE_REJECTED = 'rejected'

    STATE_CHOICES = (
        (STATE_NEW, 'Новый'),
        (STATE_AGREEMENT, 'На согласовании'),
        (STATE_APPROVED, 'Утверждён'),
        (STATE_REJECTED, 'Отклонён'),
    )

    title = models.CharField(max_length=200)
    state = FSMField(default=STATE_NEW, choices=STATE_CHOICES, protected=True)

    @transition(field=state, source=STATE_NEW, target=STATE_AGREEMENT)
    def send_for_agreement(self):
        # Логика, выполняемая при переходе
        print(f"Документ '{self.title}' отправлен на согласование.")
```

### 2.3. Микрошаги по реализации

1.  **Установка `django-fsm`:** `pip install django-fsm`.
2.  **Добавление `FSMField`:** Добавьте поле состояния в вашу модель. `protected=True` запрещает прямое изменение состояния, разрешая его менять только через `transition`.
3.  **Описание переходов:** Используйте декоратор `@transition` для описания разрешённых переходов. Внутри функции перехода можно описать побочные эффекты.
4.  **Создание промпта для Cursor (режим Кодирования):**

    ```markdown
    @USER_PROFILE.xml
    @rules/grace.md
    @documents/models.py

    **Контекст:** У нас есть модель `Document`. Нужно автоматизировать её жизненный цикл.

    **Задача:** Интегрируй `django-fsm` в модель `Document`. Добавь поле `state` и определи следующий жизненный цикл:
    1. `new` -> `agreement` (переход `send_for_agreement`)
    2. `agreement` -> `approved` (переход `approve`)
    3. `agreement` -> `rejected` (переход `reject`)

    Сделай поле `state` защищённым от прямого изменения.

    **THINKING_TOKENS:**
    - Нужно импортировать `FSMField` и `transition`.
    - Поле `state` должно быть `FSMField` с `protected=True`.
    - Нужно определить три функции, декорированные `@transition`, для каждого перехода.
    ```


---

## Раздел 3: Контроль результата (Monitoring & Analytics)

После того как процессы запущены, необходимо контролировать их выполнение и анализировать результаты. Этот модуль отвечает за прозрачность системы и предоставляет данные для принятия управленческих решений.

### 3.1. Архитектура модуля контроля

Архитектура модуля контроля фокусируется на сборе, агрегации и визуализации данных о бизнес-процессах.

| Компонент | Технология | Назначение |
|---|---|---|
| **Аудит действий** | `django-auditlog` / `django-simple-history` | Запись всех изменений, происходящих с ключевыми моделями. Кто, что и когда изменил. |
| **Агрегация данных** | Django ORM / Raw SQL | Периодический расчёт ключевых показателей эффективности (KPI) на основе сырых данных. |
| **Визуализация (Дашборды)** | Custom Django Views + Chart.js / Plotly | Отображение KPI в виде графиков и таблиц в интерфейсе АРМ. |
| **Отчётность** | FPDF2 / ReportLab | Генерация регламентных отчётов в форматах PDF или XLSX по запросу или расписанию. |

### 3.2. Структура Django-проекта

Для контроля и отчётности можно создать отдельное приложение `dashboards`.

```
my_project/
├── ...
├── dashboards/  <-- Новое приложение
│   ├── __init__.py
│   ├── views.py       # Views для отображения дашбордов
│   ├── utils.py       # Функции для расчёта KPI
│   └── ...
├── ...
```

### 3.3. Микрошаги по реализации

1.  **Настройка аудита:** Установите `django-auditlog` и зарегистрируйте модели, историю изменений которых вы хотите отслеживать.
2.  **Создание дашборда:** Разработайте view, который собирает необходимые данные (например, количество документов в каждом статусе) и передаёт их в шаблон.
3.  **Визуализация:** В шаблоне используйте `Chart.js` для построения графиков на основе полученных данных.
4.  **Создание промпта для Cursor (режим Кодирования):**

    ```markdown
    @USER_PROFILE.xml
    @rules/grace.md
    @documents/models.py
    @dashboards/views.py

    **Контекст:** Мы создаём дашборд для контроля за процессом согласования документов.

    **Задача:** В `dashboards/views.py` создай view `document_stats_dashboard`. Он должен:
    1. Посчитать количество документов в каждом из статусов (new, agreement, approved, rejected) с помощью Django ORM.
    2. Передать эти данные в шаблон `dashboards/document_stats.html`.

    **THINKING_TOKENS:**
    - Нужно импортировать модель `Document`.
    - Для подсчёта можно использовать `Count` и `group_by` из Django ORM.
    - Результат должен быть в формате, удобном для Chart.js, например, два списка: `labels` и `data`.
    ```

---

## Раздел 4: Автоматизация (Automation)

Этот модуль — следующий шаг после внедрения процессов. Он позволяет автоматизировать рутинные действия, выполняемые по расписанию или по триггеру из внешней системы. Это высвобождает время сотрудников для более сложных и творческих задач.

### 4.1. Архитектура модуля автоматизации

Ядром модуля является асинхронный исполнитель задач, который работает независимо от основного веб-приложения.

| Компонент | Технология | Назначение |
|---|---|---|
| **Фоновые задачи** | Celery | Выполнение долгих или ресурсоёмких операций в фоне (например, отправка email-рассылки, генерация отчёта). |
| **Задачи по расписанию** | Celery Beat | Периодический запуск задач (например, ежедневный сбор статистики, проверка статусов). |
| **Внешние триггеры** | Webhooks | Запуск внутренних процессов из внешних систем (например, получение уведомления об оплате из банка). |
| **Визуальные воркфлоу** | N8n | Создание сложных, многошаговых сценариев автоматизации с ветвлением и интеграцией с сотнями сервисов без написания кода. |

### 4.2. Интеграция с N8n

Django и N8n — мощная связка. Django выступает как система-источник данных и бизнес-логики, а N8n — как универсальный оркестратор, который связывает Django с внешним миром.

**Пример:** При переводе документа в статус `approved` в Django, нужно создать задачу в Jira и отправить уведомление в Slack.

1.  В Django, при переходе FSM в состояние `approved`, отправляется POST-запрос на Webhook-URL в N8n с данными документа.
2.  В N8n настроен воркфлоу, который:
    *   Принимает данные от Django.
    *   Создаёт тикет в Jira через Jira API Node.
    *   Отправляет сообщение в Slack через Slack API Node.

### 4.3. Микрошаги по реализации (Celery Beat)

1.  **Настройка Celery Beat:** Настройте планировщик в `settings.py`.
2.  **Создание задачи:** Напишите Celery-задачу, например, для архивации старых документов.
3.  **Создание промпта для Cursor (режим Кодирования):**

    ```markdown
    @USER_PROFILE.xml
    @rules/grace.md
    @documents/tasks.py

    **Контекст:** Нужно автоматически архивировать утверждённые документы старше 365 дней.

    **Задача:** В `documents/tasks.py` создай Celery-задачу `archive_old_documents`. Она должна:
    1. Найти все `Document` со статусом `approved`, которые были созданы более года назад.
    2. Изменить их статус на `archived` (предполагается, что такой статус добавлен в модель).
    3. Настроить Celery Beat для запуска этой задачи каждый день в 2 часа ночи.

    **THINKING_TOKENS:**
    - Для поиска документов нужно использовать `filter()` с `__lt` и `datetime`.
    - Для изменения статуса нужно будет вызвать FSM-переход `archive()`.
    - Расписание для Celery Beat задаётся в `settings.py` в словаре `CELERY_BEAT_SCHEDULE`.
    ```


---

## Раздел 5: Искусственный интеллект (AI Integration)

ИИ — это высший уровень развития АРМ, который превращает его из инструмента для выполнения задач в интеллектуального помощника. Интеграция ИИ позволяет автоматизировать не только рутинные, но и когнитивные операции: подготовка ответов, анализ документов, поиск информации.

### 5.1. Архитектура модуля ИИ

Архитектура ИИ-модуля в АРМ строится на базе LLM, которая интегрируется в существующие бизнес-процессы.

| Компонент | Технология | Назначение |
|---|---|---|
| **ИИ-ассистент (Copilot)** | Custom Django View + LLM API | Встраиваемый помощник, который помогает пользователю в контексте его текущей задачи (например, "напиши ответ на это письмо"). |
| **База знаний (RAG)** | `pgvector` + Django | Предоставление LLM доступа к внутренней документации компании для генерации ответов на основе релевантной информации. |
| **Анализ документов** | LLM (Function Calling) | Автоматическое извлечение структурированных данных из неструктурированных документов (например, извлечение суммы и даты из счёта-фактуры). |
| **Умный поиск** | Vector Search (Embeddings) | Поиск по смыслу, а не по ключевым словам, по всей базе документов и справочников. |

### 5.2. Пример: ИИ-ассистент для ответа на обращения

Представим АРМ для службы поддержки. Пользователь открывает тикет, и ему нужно написать ответ.

1.  Пользователь нажимает кнопку "Помочь с ответом".
2.  Django-бэкенд отправляет запрос к LLM, который включает:
    *   Текст тикета от клиента.
    *   Историю предыдущих обращений этого клиента.
    *   Результаты RAG-поиска по базе знаний (инструкции, похожие решённые тикеты).
3.  LLM генерирует черновик ответа.
4.  Пользователь редактирует черновик и отправляет его клиенту.

### 5.3. Микрошаги по реализации (RAG)

1.  **Настройка `pgvector`:** Установите расширение в PostgreSQL.
2.  **Создание модели для чанков:** Создайте модель, где будет храниться текст документа, разбитый на части (чанки), и векторное представление каждого чанка.
3.  **Индексация:** Напишите Django-команду, которая будет проходить по документам, нарезать их на чанки, получать для каждого вектор (embedding) через API (например, OpenAI) и сохранять в базу.
4.  **Создание промпта для Cursor (режим Архитектора):**

    ```markdown
    @USER_PROFILE.xml
    @rules/grace.md

    **Контекст:** Мы создаём ИИ-ассистента для АРМ службы поддержки. Нам нужна RAG-система для поиска по базе знаний.

    **Задача:** Спроектируй Django-модель `KnowledgeChunk` для хранения чанков документов и их векторных представлений. Также спроектируй функцию `find_relevant_chunks(query_text)`, которая принимает текст запроса, векторизует его и находит 3 самых близких чанка в базе данных с помощью косинусного расстояния в `pgvector`.

    **План (PCAM):**
    - **Purpose:** Создать основу для RAG-системы: хранилище векторов и функцию поиска.
    - **Context:** Django, `pgvector`, OpenAI API для эмбеддингов.
    - **Audience:** Я, разработчик.
    - **Medium:** Код в `support/models.py` и `support/rag.py`.

    **THINKING_TOKENS:**
    - Модель `KnowledgeChunk` должна содержать `TextField` для текста и поле `VectorField` из `pgvector.django`.
    - Функция `find_relevant_chunks` должна сначала получить вектор для `query_text`.
    - Затем она должна использовать `CosineDistance` из `pgvector.django` для поиска ближайших векторов в базе.
    ```

---

## Заключение

Проектирование АРМ — это комплексная задача, которая требует системного подхода. Разделение системы на 5 ключевых модулей (Справочники, Процессы, Контроль, Автоматизация, ИИ) и использование правильных архитектурных паттернов и инструментов для каждого из них позволяет создавать масштабируемые, надёжные и по-настоящему полезные для бизнеса системы. Этот гайд, в связке с универсальным шаблоном, даёт вам полную методологию для такой работы в Cursor.
